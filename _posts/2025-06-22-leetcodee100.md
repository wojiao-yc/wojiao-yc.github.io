---
date: 2025-06-20 18:00:00
layout: post
title: Leetcode刷题记录
subtitle: 到头来还是得做一做算法题
description: 用于记录刷 LeetCode 的 hot 100，做了就忘光光，还是得稍微记录一下
image: ..\assets\img\posts\leetcode\leetcode100.png
optimized_image: ..\assets\img\posts\leetcode\leetcode100.png
category: study
tags:
  - leetcode
  - algorithm
author: wojiao-yc
---

## 目录

### 哈希
[两数之和](#两数之和)

### 子串
[和为K的子数组](#和为K的子数组)

### 数组
[最大子数组和](#最大子数组和)


## 哈希

### 两数之和

题目链接：[leetcode 1](https://leetcode.cn/problems/two-sum/)

**题解：**
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        //-------------------------------------------
        // 需要修改原始数据 vector<int>& nums
        // 只读取数据，不修改 const vector<int>& nums 
        // 需要原始数据的独立副本（罕见） vector<int> nums（值传递）
        // unordered_map<int, int> hashtable; # 构建一个哈希表，key是数值，value是索引
        //-------------------------------------------
        for (int i = 0; i < nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]); // auto自动判断类型
            if (it != hashtable.end()) { // 没找到返回 end() 迭代器
                return {it->second, i}; // 通过 it->second 获取哈希表中存储的索引
            }
            hashtable[nums[i]] = i; // 由于只有唯一答案，在寻找后将元素加入
        }
        return {};
    }
};
```

**要注意的点**
- 题干讲到只有唯一解，每次寻找后再将元素加入哈希表，后续会将该元素纳入查找范围，避免了查找自己，又没有遗漏

[回到目录](#目录)

---


## 子串

### 和为K的子数组

题目链接：[leetcode 560](https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked)

**题解：**
```cpp
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        unordered_map<int, int> mp; // 构造一个哈希表用于记录前缀和出现的次数
        int count = 0; // 用于记录当前的前缀和
        int ans = 0; 
        for(int i =  0; i < nums.size(); i++){
            mp[count]++; // 记录当前位置前缀和的数量
            count += nums[i];
            if(mp.find(count - k) != mp.end()){ // 查找是否存在从某个位置到当前位置和为K
                ans += mp[count - k]; // 加上满足该条件前缀和的数量
            }
        }
        return ans;
    }
};
```

**要注意的点**
- 由于数据可能有负数，从当前位置向前看，前缀和满足条件的有多个，即有相同的前缀和，因此哈希表记录的是前缀和的值，以及其出现次数

[回到目录](#目录)

--- 

## 数组

### 最大子数组和

题目链接：[leetcode 53](https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked)

**题解：**
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> maxNow(nums.size()); // 初始化一个动态数组，用于记录以i结尾的最大子数组和
        maxNow[0] = nums[0]; // 由于后面有用上 i-1 这里要进行初始化
        int ansMax = nums[0]; // 遍历一遍找到最大的值
        for(int i = 1; i < nums.size();i++){
            maxNow[i] = max(nums[i] + maxNow[i-1], nums[i]); // 确定是否要加上前面的部分
            ansMax = max(ansMax, maxNow[i]);
        }
        return ansMax;
    }
};

```

**要注意的点**
- 整体的最大子数组和并不是以最后一个元素结尾的最大子数组和，需要寻找，ansMax就是这个作用
- i结尾的最大子数组和，就看i-1结尾的最大子数组和是否大于0，再加上第i个元素

[回到目录](#目录)

--- 

## 矩阵

### 矩阵置零

题目链接：[leetcode 73](https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked)

**题解：**
```cpp
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
        int col = matrix.size();
        int row = matrix[0].size();
        vector<bool> col_zero(col, false); // 用于记录有0的行
        vector<bool> row_zero(row, false); // 用于记录有0的列
        for(int i = 0; i < col; i++){
            for(int j = 0; j < row; j++){
                if(matrix[i][j] == 0){
                    col_zero[i] = row_zero[j] = 1;
                }
            }
        }
        for(int i = 0; i < col; i++){
            for(int j = 0; j < row; j++){
                if(col_zero[i] ==1 || row_zero[j] == 1){
                    matrix[i][j] = 0;
                }
            }
        } 
        
    }
};

```

**要注意的点**
- 其实就是思路上用行和列来表示位置即可

[回到目录](#目录)

--- 
